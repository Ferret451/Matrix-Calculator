unit frmMain;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes,
  Vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, Vcl.Menus,
  System.Actions, Vcl.ActnList, Vcl.ExtCtrls, System.ImageList, Vcl.ImgList, Vcl.ToolWin,
  Vcl.ComCtrls, untExprCalculate, clsDoubleLinkedList, clsMatrix, clsMatrixList,
  clsDataManager, frmMatrList, frmEditMatr, Vcl.NumberBox, untConstants, untTypes,
  Vcl.Grids, frmHTML, untPainting, untMatrixCalc, Vcl.ButtonGroup, untStatistics,
  untSaveLoad;

type
  TMainForm = class(TForm)
    MainMenu: TMainMenu;
    mmFile: TMenuItem;
    mmOpen: TMenuItem;
    mmSave: TMenuItem;
    mmSaveAs: TMenuItem;
    ToolBar: TToolBar;
    alToolBar: TActionList;
    ilToolBar: TImageList;
    mmNew: TMenuItem;
    mmExit: TMenuItem;
    aNewFile: TAction;
    tbSaveFileAs: TToolButton;
    aSaveFileAs: TAction;
    aSaveFile: TAction;
    tbSaveFile: TToolButton;
    tbNewFile: TToolButton;
    aOpenFile: TAction;
    tbOpenFile: TToolButton;
    N1: TMenuItem;
    aExit: TAction;
    mmMatrix: TMenuItem;
    mmViewList: TMenuItem;
    aViewMatrixList: TAction;
    tbViewMatrixList: TToolButton;
    Clearlist1: TMenuItem;
    tbSeparator1: TToolButton;
    mmInfo: TMenuItem;
    mmHelp: TMenuItem;
    mmAbout: TMenuItem;
    aOpenHelp: TAction;
    aOpenAbout: TAction;
    mmStatistics: TMenuItem;
    mmCurrentStat: TMenuItem;
    mmOtherStat: TMenuItem;
    odMain: TOpenDialog;
    panCalculatorButtons: TPanel;
    butTwo: TButton;
    butFive: TButton;
    butThree: TButton;
    butSix: TButton;
    butOne: TButton;
    butFour: TButton;
    butEight: TButton;
    butSeven: TButton;
    butNine: TButton;
    butZero: TButton;
    butComma: TButton;
    butDelete: TButton;
    butCalculate: TButton;
    butPlus: TButton;
    butMinus: TButton;
    butMultiplication: TButton;
    butDivision: TButton;
    butClear: TButton;
    butExponentaition: TButton;
    panCalcChoose: TPanel;
    butExpressionChoose: TButton;
    butDeterminantChoose: TButton;
    butInverseChoose: TButton;
    butRankChoose: TButton;
    butMant: TButton;
    butMoveLeft: TButton;
    butMoveRight: TButton;
    butOpenBrace: TButton;
    butCloseBrace: TButton;
    sbExpression: TScrollBox;
    pbExpression: TPaintBox;
    labX: TLabel;
    edExpression: TEdit;
    sgDeterminant: TStringGrid;
    sgInverse: TStringGrid;
    sgRank: TStringGrid;
    edColumnsAmount: TEdit;
    edLinesAmount: TEdit;
    butAddDimension: TButton;
    butRemoveDimension: TButton;
    sdMain: TSaveDialog;
    butMoveUp: TButton;
    butMoveDown: TButton;

    procedure edExpressionExit(Sender: TObject);
    procedure butCalculateClick(Sender: TObject);
    procedure butInputClick(Sender: TObject);
    procedure butDeleteClick(Sender: TObject);
    procedure butClearClick(Sender: TObject);
    procedure aSaveFileAsExecute(Sender: TObject);
    procedure aSaveFileExecute(Sender: TObject);
    procedure aNewFileExecute(Sender: TObject);
    procedure aOpenFileExecute(Sender: TObject);
    procedure aExitExecute(Sender: TObject);
    procedure aViewMatrixListExecute(Sender: TObject);
    procedure aClearMatrixListExecute(Sender: TObject);
    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure pbExpressionPaint(Sender: TObject);
    procedure edExpressionChange(Sender: TObject);
    procedure sgResize(Sender: TObject);
    procedure butAddDimensionClick(Sender: TObject);
    procedure butRemoveDimensionClick(Sender: TObject);
    procedure butChooseClick(Sender: TObject);
    procedure aExecuteInfo(Sender: TObject);
    procedure edDimensionsExit(Sender: TObject);
    procedure sgInputMatrixAssign(Sender: TObject; const AMatrix: TMatrix<string>);
    procedure sgInputMatrixSetEditText(Sender: TObject; ACol, ARow: Integer;
      const Value: string);
    procedure sgSelectSpecificCell(ACol, ARow: Integer;
      AStringGrid: TStringGrid);
    procedure sbExpressionClick(Sender: TObject);
    procedure sbExpressionMouseWheel(Sender: TObject; Shift: TShiftState;
      WheelDelta: Integer; MousePos: TPoint; var Handled: Boolean);
    procedure mmCurrentStatClick(Sender: TObject);
    procedure mmOtherStatClick(Sender: TObject);
    procedure panCalculatorButtonsResize(Sender: TObject);
    procedure FormClose(Sender: TObject; var Action: TCloseAction);
    procedure butMoveSelectionClick(Sender: TObject);
  private
    FCarriagePos: Integer;
    FsgLeft: Integer;
    FsgTop: Integer;

    FStatistics: TUserInfo;
    FLastSavePath: string;
    FIsSaved: Boolean;

    procedure butMoveSelectClick(Sender: TObject);
    function TryStrToNatural(const ANumberSting: string; var ANumber: Integer): Boolean;
    function sgGetCurrent(): TStringGrid;
    function TryToSaveAndContinue(): Boolean;
    procedure ViewUpdate();
  public

  end;

var
  MainForm: TMainForm;

implementation

{$R *.dfm}

procedure TMainForm.FormClose(Sender: TObject; var Action: TCloseAction);
begin
  if TryToSaveAndContinue then
  begin
    Action := caFree;
  end
  else
    Action := caNone;
end;

procedure TMainForm.FormCreate(Sender: TObject);
begin
  ClearUserInfo(FStatistics);
  FStatistics.FLoginTime := Now;
  FStatistics.FUserName := GetWindowsUserName;
  FStatistics.FExpressionCalcAmount := 0;
  FStatistics.FDeterminantCalcAmount := 0;
  FStatistics.FInverseCalcAmount := 0;
  FStatistics.FRankCalcAmount := 0;
  FStatistics.FDeterminantMatrChangeAmount := 0;
  FStatistics.FInverseMatrChangeAmount := 0;
  FStatistics.FRankMatrChangeAmount := 0;
  FLastSavePath := '';

  DataManager := TDataManager.Create();
  FCarriagePos := 1;
end;

procedure TMainForm.FormDestroy(Sender: TObject);
begin
  FStatistics.FLogoutTime := Now;
  SaveStatistics(FStatistics);

  DataManager.Destroy();
end;

procedure TMainForm.mmCurrentStatClick(Sender: TObject);
begin
  ShowMessage(FormatStatistics(Self.FStatistics));
end;

procedure TMainForm.mmOtherStatClick(Sender: TObject);
begin
  odMain.DefaultExt := constExtStat;
  var FilePath: string := IncludeTrailingPathDelimiter(ExtractFilePath(ParamStr(0))) +
    dirAppData;
  if DirectoryExists(FilePath) then
    odMain.InitialDir := FilePath;
  if odMain.Execute then
    ShowMessage(FormatStatistics(LoadStatistics(odMain.FileName)));
  odMain.InitialDir := '';
end;

procedure TMainForm.aClearMatrixListExecute(Sender: TObject);
begin
//
end;

function TMainForm.TryToSaveAndContinue(): Boolean;
var
  Answer: Integer;
begin
  Answer := MessageDlg(msTryToSave, mtInformation, [mbYes, mbNo, mbCancel], 0);
  case Answer of
    mrYes:
    begin
      aSaveFileExecute(MainForm);
      Result := True;
    end;

    mrNo:
      Result := True;

    mrCancel:
      Result := False;
  end;
end;

procedure TMainForm.aNewFileExecute(Sender: TObject);
begin
  if TryToSaveAndContinue then
  begin
    FLastSavePath := '';

  end;
end;

procedure TMainForm.aOpenFileExecute(Sender: TObject);
var
  FilePath, FileExt: string;
begin
  if TryToSaveAndContinue() then
  begin
    odMain.DefaultExt := constExtFile;
    FilePath := 'C:\';
    if DirectoryExists(FilePath) then
      odMain.InitialDir := FilePath;
    if odMain.Execute then
    begin
      FilePath := odMain.FileName;
      FileExt := ExtractFileExt(FilePath);
      if FileExt = constExtFile then
      begin
        OpenMatrFile(odMain.FileName);
        ViewUpdate;
      end;
    end;
    odMain.InitialDir := '';
  end;
end;

procedure TMainForm.aSaveFileExecute(Sender: TObject);
begin
  if FLastSavePath = '' then
    aSaveFileAsExecute(MainForm)
  else
    SaveMatrFile(FLastSavePath);
end;

procedure TMainForm.aSaveFileAsExecute(Sender: TObject);
var
  FilePath: string;
begin
  sdMain.DefaultExt := constExtFile;
  if FLastSavePath = '' then
    FilePath := 'C:\'
  else
    FilePath := ExtractFilePath(FLastSavePath);
  if DirectoryExists(FilePath) then
    sdMain.InitialDir := FilePath;
  if sdMain.Execute then
  begin
    FLastSavePath := sdMain.FileName;

    SaveMatrFile(FLastSavePath);
  end;
  sdMain.InitialDir := '';
end;

procedure TMainForm.aExitExecute(Sender: TObject);
begin
  Close;
end;

procedure TMainForm.aExecuteInfo(Sender: TObject);
begin
  case TComponent(Sender).Tag of
    1:
      HTMLForm.Execute('Help');
    2:
      HTMLForm.Execute('About Program');
  end;
end;

procedure TMainForm.aViewMatrixListExecute(Sender: TObject);
begin
  MatrixListForm.Show;
end;

procedure TMainForm.panCalculatorButtonsResize(Sender: TObject);
var
  i: Integer;
begin

end;

procedure TMainForm.ViewUpdate();
  procedure sgUpdate(const AStringGrid: TStringGrid; const AOpearation: TFullOperation);
  var
    i, j: Integer;
  begin
    AStringGrid.RowCount := AOpearation.FProblemMatrix.LinesAmount;
    AStringGrid.ColCount := AOpearation.FProblemMatrix.ColumnsAmount;
    for i := 0 to AStringGrid.RowCount - 1 do
      for j := 0 to AStringGrid.ColCount - 1 do
        AStringGrid.Cells[j, i] := AOpearation.FProblemMatrix.Element[i, j];
  end;
begin
  edExpression.Text := DataManager.CurrentExpression.FProblemString;
  edLinesAmount.Text := IntToStr(DefaultMatrixLength);
  edColumnsAmount.Text := IntToStr(DefaultMatrixHeight);

  sgUpdate(sgDeterminant, DataManager.CurrentDeterminant);
  sgUpdate(sgInverse, DataManager.CurrentInverse);
  sgUpdate(sgRank, DataManager.CurrentRank);
  sgResize(sgDeterminant);
  sgResize(sgInverse);
  sgResize(sgRank);
end;

procedure TMainForm.pbExpressionPaint(Sender: TObject);
var
  X, Y: Integer;
  TextToOut: string;
begin
  case DataManager.OperationStatement of
    ostatExpression:
    begin
      X := StartPosX;
      Y := StartPosY + 30;

      if DataManager.CurrentExpression.FAnswer.FIsMatrix then
      begin
        MatrixPaint(X, Y, DataManager.CurrentExpression.FAnswer.FMatrix,
          BraceOutline, pbExpression);
      end
      else
      begin
        pbExpression.Canvas.TextOut(X, Y,
          FloatToStr(DataManager.CurrentExpression.FAnswer.FNumber));
      end;
    end;

    ostatDeterminant:
    begin
      X := FsgLeft;
      Y := FsgTop;

      DetOutline(X, Y, sgDeterminant.Height,
        sgDeterminant.Width, pbExpression);

      X := X + sgDeterminant.Width + ColumnInterval shl 1;
      TextToOut := ' = ' +
        FloatToStr(DataManager.CurrentDeterminant.FAnswer.FNumber);
      MidMatrixTextPrint(X, Y, sgDeterminant.Height, TextToOut, pbExpression);

      pbExpression.Width := X + ColumnInterval;
      pbExpression.Height := FsgTop + sgDeterminant.Height + LineInterval shl 1;
    end;

    ostatInverse:
    begin
      X := FsgLeft;
      Y := FsgTop;

      BraceOutline(X, Y, sgInverse.Height,
        sgInverse.Width, pbExpression);

      X := X + sgInverse.Width + ColumnInterval shl 1;
      TextToOut := ' = ';
      MidMatrixTextPrint(X, Y, sgInverse.Height, TextToOut, pbExpression);

      X := X + ColumnInterval;
      Y := Y - (pbExpression.Canvas.TextHeight(TextToOut) +
        GetMatrixHeight(DataManager.CurrentInverse.FAnswer.FMatrix, pbExpression)) shr 1 -
        LineInterval;

      MatrixPaint(X, Y, DataManager.CurrentInverse.FAnswer.FMatrix, BraceOutline,
        pbExpression);

      pbExpression.Width := X + ColumnInterval shl 1;
      pbExpression.Height := FsgTop + sgInverse.Height + LineInterval shl 1;
    end;

    ostatRank:
    begin
      X := FsgLeft;
      Y := FsgTop;

      BraceOutline(X, Y, sgRank.Height, sgRank.Width,
        pbExpression);

      X := X + sgRank.Width + ColumnInterval shl 1;
      TextToOut := ' = ' +
        FloatToStr(DataManager.CurrentRank.FAnswer.FNumber);
      MidMatrixTextPrint(X, Y, sgRank.Height, TextToOut, pbExpression);

      pbExpression.Width := X + ColumnInterval;
      pbExpression.Height := FsgTop + sgRank.Height + LineInterval shl 1;
    end;
  end;
end;

procedure TMainForm.edExpressionChange(Sender: TObject);
begin
  DataManager.SetStringProblem(edExpression.Text, DataManager.CurrentExpression);
end;

procedure TMainForm.edExpressionExit(Sender: TObject);
begin
  FCarriagePos := edExpression.SelStart;
end;

procedure TMainForm.butCalculateClick(Sender: TObject);
var
  Answer: TAnswer;
  Matrix: TMatrix<Extended>;
begin
  Answer := DataManager.CurrentAnswer;

  case DataManager.OperationStatement of
    ostatExpression:
    begin
      if ExprCalculation(edExpression.Text, Answer) then
      begin
        DataManager.CurrentAnswer := Answer;
        inc(FStatistics.FExpressionCalcAmount);
      end;
    end;

    ostatDeterminant:
    begin
      sgResize(sgGetCurrent);
      Matrix := TMatrix<Extended>.Create(DataManager.CurrentDeterminant.FProblemMatrix.LinesAmount,
        DataManager.CurrentDeterminant.FProblemMatrix.ColumnsAmount);
      if DataManager.TryProblemMatrixToExtended(DataManager.CurrentDeterminant.FProblemMatrix,
        Matrix) then
      begin
        inc(FStatistics.FDeterminantCalcAmount);
        Answer.FIsMatrix := False;
        Answer.FNumber := FindDeterminant(Matrix);
        DataManager.CurrentAnswer := Answer;
      end
      else
        ShowMessage('Incorrect matrix element was found');
      Matrix.Destroy;
    end;

    ostatInverse:
    begin
      sgResize(sgGetCurrent);
      Matrix := TMatrix<Extended>.Create(DataManager.CurrentInverse.FProblemMatrix.LinesAmount,
        DataManager.CurrentInverse.FProblemMatrix.ColumnsAmount);
      if DataManager.TryProblemMatrixToExtended(DataManager.CurrentInverse.FProblemMatrix,
        Matrix) then
      begin
        inc(FStatistics.FInverseCalcAmount);
        Answer.FIsMatrix := True;
        Answer.FMatrix.LinesAmount := DataManager.CurrentInverse.FProblemMatrix.LinesAmount;
        Answer.FMatrix.ColumnsAmount := DataManager.CurrentInverse.FProblemMatrix.ColumnsAmount;
        Answer.FMatrix.MartixUpdate();
        FindInverse(Matrix, Answer.FMatrix);
        DataManager.CurrentAnswer := Answer;
      end
      else
        ShowMessage('Incorrect matrix element was found');
      Matrix.Destroy;
    end;

    ostatRank:
    begin
      sgResize(sgGetCurrent);
      Matrix := TMatrix<Extended>.Create(DataManager.CurrentRank.FProblemMatrix.LinesAmount,
        DataManager.CurrentRank.FProblemMatrix.ColumnsAmount);
      if DataManager.TryProblemMatrixToExtended(DataManager.CurrentRank.FProblemMatrix,
        Matrix) then
     begin
        inc(FStatistics.FRankCalcAmount);
        Answer.FIsMatrix := False;
        Answer.FNumber := FindRank(Matrix);
        DataManager.CurrentAnswer := Answer;
      end
      else
        ShowMessage('Incorrect matrix element was found');
      Matrix.Destroy;
    end;
  end;

  DataManager.CallBack(pbExpression);
end;

procedure TMainForm.butClearClick(Sender: TObject);
var
  SelectedCol, SelectedRow: Integer;
begin
  if DataManager.OperationStatement = ostatExpression then
  begin
    edExpression.Text := '';
    FCarriagePos := 1;
    edExpression.SetFocus;
    edExpression.SelStart := FCarriagePos;
  end
  else
  begin
    SelectedCol := sgGetCurrent.Col;
    SelectedRow := sgGetCurrent.Row;
    sgGetCurrent.Cells[SelectedCol, SelectedRow] := '';
    sgGetCurrent.SetFocus;
    sgGetCurrent.EditorMode := True;
  end;
end;

procedure TMainForm.butInputClick(Sender: TObject);
var
  SelectedCol, SelectedRow: Integer;
begin
  if DataManager.OperationStatement = ostatExpression then
  begin
    edExpression.Text := Copy(edExpression.Text, 1, FCarriagePos) +
      (Sender as TButton).Caption + Copy(edExpression.Text, FCarriagePos + 1);
    FCarriagePos := FCarriagePos + Length((Sender as TButton).Caption);
    edExpression.SetFocus;
    edExpression.SelStart := FCarriagePos;
  end
  else
  begin
    SelectedCol := sgGetCurrent.Col;
    SelectedRow := sgGetCurrent.Row;
    sgGetCurrent.Cells[SelectedCol, SelectedRow] :=
      sgGetCurrent.Cells[SelectedCol, SelectedRow] + (Sender as TButton).Caption;
    sgGetCurrent.SetFocus;
    sgGetCurrent.EditorMode := True;
  end;
end;

procedure TMainForm.butMoveSelectionClick(Sender: TObject);
begin
  if DataManager.OperationStatement = ostatExpression then
  begin
    case TButton(Sender).Tag of
      2:
      begin
        if FCarriagePos > 0 then
        begin
          dec(FCarriagePos);
          edExpression.SetFocus;
          edExpression.SelStart := FCarriagePos;
        end;
      end;

      3:
      begin
        if FCarriagePos < Length(edExpression.Text)  then
        begin
          inc(FCarriagePos);
          edExpression.SetFocus;
          edExpression.SelStart := FCarriagePos;
        end;
      end;
    end;
  end
  else
    case TButton(Sender).Tag of
      0:
      begin
        if sgGetCurrent.Row > 0 then
        begin
          sgGetCurrent.Row := sgGetCurrent.Row - 1;
          sgGetCurrent.SetFocus;
        end;
      end;

      1:
      begin
        if sgGetCurrent.Row < sgGetCurrent.RowCount - 1 then
        begin
          sgGetCurrent.Row := sgGetCurrent.Row + 1;
          sgGetCurrent.SetFocus;
        end;
      end;

      2:
      begin
        if sgGetCurrent.Col > 0 then
        begin
          sgGetCurrent.Col := sgGetCurrent.Col - 1;
          sgGetCurrent.SetFocus;
        end;
      end;

      3:
      begin
        if sgGetCurrent.Col < sgGetCurrent.ColCount - 1 then
        begin
          sgGetCurrent.Col := sgGetCurrent.Col + 1;
          sgGetCurrent.SetFocus;
        end;
      end;
    end;
end;

procedure TMainForm.butMoveSelectClick(Sender: TObject);
begin
  if DataManager.OperationStatement = ostatExpression then
  begin
    case TButton(Sender).Tag of
      NativeInt(sdLeft):
      begin
        if FCarriagePos > 1 then
        begin
          dec(FCarriagePos);
          edExpression.SelStart := FCarriagePos;
          edExpression.SetFocus;
        end;
      end;
    end;
  end;
end;

procedure TMainForm.butDeleteClick(Sender: TObject);
var
  SelectedCol, SelectedRow: Integer;
begin
  if DataManager.OperationStatement = ostatExpression then
  begin
    if FCarriagePos >= 1 then
    begin
      edExpression.Text := Copy(edExpression.Text, 1, FCarriagePos - 1) +
        Copy(edExpression.Text, FCarriagePos + 1);
      dec(FCarriagePos);
      edExpression.SetFocus;
      edExpression.SelStart := FCarriagePos
    end;
  end
  else
  begin
    SelectedCol := sgGetCurrent.Col;
    SelectedRow := sgGetCurrent.Row;
    sgGetCurrent.Cells[SelectedCol, SelectedRow] :=
      Copy(sgGetCurrent.Cells[SelectedCol, SelectedRow], 1,
        Length(sgGetCurrent.Cells[SelectedCol, SelectedRow]) - 1);
    sgGetCurrent.SetFocus;
    sgGetCurrent.EditorMode := True;
  end;
end;

procedure TMainForm.butChooseClick(Sender: TObject);
begin
  edExpression.Visible := False;
  sgDeterminant.Visible := False;
  sgInverse.Visible := False;
  sgRank.Visible := False;
  butAddDimension.Visible := False;
  butRemoveDimension.Visible := False;
  edLinesAmount.Visible := False;
  edColumnsAmount.Visible := False;
  labX.Visible := False;
  butExpressionChoose.Enabled := True;
  butDeterminantChoose.Enabled := True;
  butInverseChoose.Enabled := True;
  butRankChoose.Enabled := True;
  butMoveUp.Enabled := True;
  butMoveDown.Enabled := True;
  if TButton(Sender).Tag = butExpressionChoose.Tag then
  begin
    DataManager.OperationStatement := ostatExpression;

    edExpression.Visible := True;
    edExpression.Text := DataManager.GetCurrentOperation.FProblemString;
    butExpressionChoose.Enabled := False;
    butMoveUp.Enabled := False;
    butMoveDown.Enabled := False;

    DataManager.CallBack(pbExpression);
  end
  else if (TButton(Sender).Tag = butDeterminantChoose.Tag) then
  begin
    DataManager.OperationStatement := ostatDeterminant;

    sgDeterminant.Visible := True;
    butAddDimension.Visible := True;
    butRemoveDimension.Visible := True;
    sgInputMatrixAssign(sgGetCurrent, DataManager.GetCurrentOperation.FProblemMatrix);
    FsgLeft := sgGetCurrent.Left;
    FsgTop := sgGetCurrent.Top;
    butDeterminantChoose.Enabled := False;

    DataManager.CallBack(pbExpression);
  end
  else if (TButton(Sender).Tag = butInverseChoose.Tag) then
  begin
    DataManager.OperationStatement := ostatInverse;

    sgInverse.Visible := True;
    butAddDimension.Visible := True;
    butRemoveDimension.Visible := True;
    sgInputMatrixAssign(sgGetCurrent, DataManager.GetCurrentOperation.FProblemMatrix);
    FsgLeft := sgGetCurrent.Left;
    FsgTop := sgGetCurrent.Top;
    butInverseChoose.Enabled := False;

    DataManager.CallBack(pbExpression);
  end
  else if (TButton(Sender).Tag = butRankChoose.Tag) then
  begin
    DataManager.OperationStatement := ostatRank;

    sgRank.Visible := True;
    edLinesAmount.Visible := True;
    edColumnsAmount.Visible := True;
    edLinesAmount.Text :=
      IntToStr(DataManager.GetCurrentOperation.FProblemMatrix.LinesAmount);
    edColumnsAmount.Text :=
      IntToStr(DataManager.GetCurrentOperation.FProblemMatrix.ColumnsAmount);
     labX.Visible := True;
    sgInputMatrixAssign(sgGetCurrent, DataManager.GetCurrentOperation.FProblemMatrix);
    FsgLeft := sgGetCurrent.Left;
    FsgTop := sgGetCurrent.Top;
    butRankChoose.Enabled := False;

    DataManager.CallBack(pbExpression);
  end;
end;

procedure TMainForm.butAddDimensionClick(Sender: TObject);
begin
  DataManager.GetCurrentOperation.FProblemMatrix.LinesAmount :=
    DataManager.GetCurrentOperation.FProblemMatrix.LinesAmount + 1;
  DataManager.GetCurrentOperation.FProblemMatrix.ColumnsAmount :=
    DataManager.GetCurrentOperation.FProblemMatrix.ColumnsAmount + 1;
  DataManager.GetCurrentOperation.FProblemMatrix.MartixUpdate();

  sgResize(sgGetCurrent);

  case DataManager.OperationStatement of
    ostatDeterminant:
      inc(FStatistics.FDeterminantMatrChangeAmount);
    ostatInverse:
      inc(FStatistics.FInverseMatrChangeAmount);
  end;
end;

procedure TMainForm.butRemoveDimensionClick(Sender: TObject);
begin
  if sgGetCurrent.RowCount > 1 then
  begin
    DataManager.GetCurrentOperation.FProblemMatrix.LinesAmount :=
      DataManager.GetCurrentOperation.FProblemMatrix.LinesAmount - 1;
    DataManager.GetCurrentOperation.FProblemMatrix.ColumnsAmount :=
      DataManager.GetCurrentOperation.FProblemMatrix.ColumnsAmount - 1;
    DataManager.GetCurrentOperation.FProblemMatrix.MartixUpdate();

    sgResize(sgGetCurrent);

    case DataManager.OperationStatement of
    ostatDeterminant:
      inc(FStatistics.FDeterminantMatrChangeAmount);
    ostatInverse:
      inc(FStatistics.FInverseMatrChangeAmount);
    end;
  end;
end;

procedure TMainForm.sbExpressionClick(Sender: TObject);
begin
  sbExpression.SetFocus;
end;

procedure TMainForm.sbExpressionMouseWheel(Sender: TObject; Shift: TShiftState;
  WheelDelta: Integer; MousePos: TPoint; var Handled: Boolean);
begin
  // Check if Shift key is pressed
  if ssShift in Shift then
  begin
    // Scroll horizontally based on the WheelDelta value
    if WheelDelta > 0 then
      sbExpression.HorzScrollBar.Position := sbExpression.HorzScrollBar.Position - ScrollStep
    else
      sbExpression.HorzScrollBar.Position := sbExpression.HorzScrollBar.Position + ScrollStep;
  end
  else
  begin
    // Scroll vertically based on the WheelDelta value
    if WheelDelta > 0 then
      sbExpression.VertScrollBar.Position := sbExpression.VertScrollBar.Position - ScrollStep
    else
      sbExpression.VertScrollBar.Position := sbExpression.VertScrollBar.Position + ScrollStep;
  end;
end;

function TMainForm.sgGetCurrent(): TStringGrid;
begin
  case DataManager.OperationStatement of
    ostatDeterminant: Result := sgDeterminant;
    ostatInverse: Result := sgInverse;
    ostatRank: Result := sgRank;
  end;
end;

procedure TMainForm.sgInputMatrixSetEditText(Sender: TObject; ACol,
  ARow: Integer; const Value: string);
begin
  DataManager.GetCurrentOperation.FProblemMatrix.Elements[ARow, ACol] :=
    TStringGrid(Sender).Cells[ACol, ARow];
end;

procedure TMainForm.sgSelectSpecificCell(ACol, ARow: Integer;
  AStringGrid: TStringGrid);
begin
  AStringGrid.Selection := TGridRect(Rect(ACol, ARow, ACol, ARow));
end;

procedure TMainForm.sgInputMatrixAssign(Sender: TObject;
  const AMatrix: TMatrix<string>);
var
  i, j: Integer;
begin
  TStringGrid(Sender).RowCount := AMatrix.LinesAmount;
  TStringGrid(Sender).ColCount := AMatrix.ColumnsAmount;
  for i := 0 to TStringGrid(Sender).RowCount - 1 do
    for j := 0 to TStringGrid(Sender).ColCount - 1 do
      TStringGrid(Sender).Cells[j, i] := AMatrix.Elements[i, j];
end;

procedure TMainForm.sgResize(Sender: TObject);
var
  LineWidth: Integer;
begin
  sgGetCurrent.RowCount := DataManager.GetCurrentOperation.FProblemMatrix.LinesAmount;
  sgGetCurrent.ColCount := DataManager.GetCurrentOperation.FProblemMatrix.ColumnsAmount;
  sgInputMatrixAssign(sgGetCurrent, DataManager.GetCurrentOperation.FProblemMatrix);

  LineWidth := GetSystemMetrics(SM_CXEDGE);
  TStringGrid(Sender).Height := (TStringGrid(Sender).DefaultRowHeight +
    LineWidth) * TStringGrid(Sender).RowCount + LineWidth div 2;
  TStringGrid(Sender).Width := (TStringGrid(Sender).DefaultColWidth +
    LineWidth) * TStringGrid(Sender).ColCount + LineWidth div 2;

  DataManager.CallBack(pbExpression);
end;

function TMainForm.TryStrToNatural(const ANumberSting: string;
  var ANumber: Integer): Boolean;
var
  Temp: Integer;
begin
  Result := TryStrToInt(ANumberSting, Temp);

  if Result then
  begin
    Result := Temp > 0;
    if Result then
      ANumber := StrToInt(ANumberSting);
  end;
end;

procedure TMainForm.edDimensionsExit(Sender: TObject);
var
  Amount: Integer;
begin
  if TryStrToNatural(TEdit(Sender).Text, Amount) then
  begin
    inc(FStatistics.FRankMatrChangeAmount);

    if TEdit(Sender).Tag = edLinesAmount.Tag then
    begin
      DataManager.GetCurrentOperation.FProblemMatrix.LinesAmount := Amount;
      DataManager.GetCurrentOperation.FProblemMatrix.MartixUpdate();
      sgResize(sgGetCurrent);
    end
    else
    begin
      if TEdit(Sender).Tag = edColumnsAmount.Tag then
      begin
        DataManager.GetCurrentOperation.FProblemMatrix.ColumnsAmount := Amount;
        DataManager.GetCurrentOperation.FProblemMatrix.MartixUpdate();
        sgResize(sgGetCurrent);
      end;
    end;
  end
  else
  begin
    ShowMessage('Inсorrect dimension');
    TEdit(Sender).SetFocus;
  end;
end;

end.
