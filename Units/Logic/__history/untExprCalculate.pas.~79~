unit untExprCalculate;

interface

uses
  System.SysUtils, Math, clsStack, clsMatrix, clsMatrixList, untConstants,
  Vcl.Dialogs, clsDataManager;

var
  OperandStack: TStack<TOperand>;
  OperatorStack: TStack<char>;

  function ExprCalculation(AExpression: string): TOperand;

implementation

function GetPriority(const AOperator: Char): ShortInt;
begin
  case AOperator of
    '+', '-':
      Result := 2;
    '*', '/':
      Result := 1;
    '^':
      Result := 0;
    '(':
      Result := -1;
    ')':
      Result := 10;
  end;
end;

function OperandProcessing(var APointerPos: Integer; const AExpression: string;
  const AOperandStack: TStack<TOperand>): Boolean;
var
  OperandString: string;
  Operand: TOperand;
begin
  Result := True;
  OperandString := '';

  while (APointerPos <= Length(AExpression)) and
    (AExpression[APointerPos] in Symbols) do
  begin
    OperandString := OperandString + AExpression[APointerPos];
    Inc(APointerPos);
  end;

  if (OperandString[APointerPos] in MatrixNameFirstElValidSymbols) then
  begin
    Operand.IsMatrix := True;
    Operand.FMatrix := TMatrix.Create;

    if DataManager.MatrixList.TryGetMatrix(OperandString, Operand.FMatrix) then
    begin
      ShowMessage('Matrix name was not found in the matrix list');
      Result := False;
    end;
  end
  else
  begin
    Operand.IsMatrix := False;

    if not TryStrToFloat(OperandString, Operand.FNumber) then
    begin
      ShowMessage('Incorrect number found');
      Result := False;
    end;
  end;

  OperandStack.Push(Operand);
end;

function OperatorProcessing(const NewOperator: Char;
  const AOperandStack: TStack<TOperand>; const AOperatorStack: TStack<Char>): Boolean;
var
  FirstOperand, SecondOperand, ResultOperand: TOperand;
  Mask : Integer;
begin
  Result := True;

  while (GetPriority(NewOperator) >= GetPriority(AOperatorStack.Top)) and
    not ((NewOperator = '^') and (AOperatorStack.Top = '^')) and
    (AOperatorStack.Top <> '(') and Result do
  begin
    SecondOperand := AOperandStack.Top;
    AOperandStack.Pop;
    FirstOperand := AOperandStack.Top;
    AOperandStack.Pop;

    if AOperandStack.Size >= 2 then
    begin
      {0 - two numbers, 1 - SecondElement is matrix
       2 - FirstElement is matrix, 3 - two numbers}
      Mask := Ord(FirstOperand.IsMatrix) shl 1 or
              Ord(SecondOperand.IsMatrix);

      case Mask Of
        $0:
        begin
          ResultOperand.IsMatrix := False;

          try
            case AOperatorStack.Top of
              '+':
                ResultOperand.FNumber := FirstOperand.FNumber + SecondOperand.FNumber;
              '-':
                ResultOperand.FNumber := FirstOperand.FNumber - SecondOperand.FNumber;
              '*':
                ResultOperand.FNumber := FirstOperand.FNumber * SecondOperand.FNumber;
              '/':
                ResultOperand.FNumber := FirstOperand.FNumber / SecondOperand.FNumber;
              '^':
                ResultOperand.FNumber := Power(FirstOperand.FNumber, SecondOperand.FNumber);
            end;
          except
            on EInvalidOp do
            begin
              ShowMessage('Final or interim result is too high or too low');
              Result := False;
            end;
            on EDivByZero do
            begin
              ShowMessage('Division on zero was found');
              Result := False;
            end;
          end;

        end;

        $1:
        begin
          ResultOperand.IsMatrix := True;

          case AOperatorStack.Top of
            '+':
            begin
              ShowMessage('Summing of number and matrix was found');
              Result := False;
            end;

            '-':
            begin
              ShowMessage('Difference of number and matrix was found');
              Result := False;
            end;

            '*':
              ResultOperand.FMatrix.AssignTo(
                SecondOperand.FMatrix.MultConst(FirstOperand.FNumber));

            '/':
            begin
              ShowMessage('Division of number on matrix was found');
              Result := False;
            end;

            '^':
            begin
              ShowMessage('Exponentiation of number to matrix was found');
              Result := False;
            end;
          end;
        end;

        $2:
        begin
          ResultOperand.IsMatrix := True;

          case AOperatorStack.Top of
            '+':
            begin
              ShowMessage('Summing of number and matrix was found');
              Result := False;
            end;

            '-':
            begin
              ShowMessage('Subtracting of number and matrix was found');
              Result := False;
            end;

            '*':
              ResultOperand.FMatrix.AssignTo(
                FirstOperand.FMatrix.MultConst(SecondOperand.FNumber));

            '/':
            begin
              ShowMessage('Division of number on matrix was found');
              Result := False;
            end;

            '^':
            begin
              ShowMessage('Exponentiation of number to matrix was found');
              Result := False;
            end;
          end;
        end;

        $3:
        begin
          ResultOperand.IsMatrix := True;

          case AOperatorStack.Top of
            '+':
            begin
              if (FirstOperand.FMatrix.Lines <> SecondOperand.FMatrix.Lines) or
                (FirstOperand.FMatrix.Columns <> SecondOperand.FMatrix.Columns) then
              begin
                ShowMessage('Matrixes dimensions does not match when summing');
                Result := False;
              end
              else
                ResultOperand.FMatrix.AssignTo(
                  FirstOperand.FMatrix.Add(SecondOperand.FMatrix));
            end;

            '-':
            begin
              if (FirstOperand.FMatrix.Lines <> SecondOperand.FMatrix.Lines) or
                (FirstOperand.FMatrix.Columns <> SecondOperand.FMatrix.Columns) then
              begin
                ShowMessage('Matrixes dimensions does not match when subtracting');
                Result := False;
              end
              else
                ResultOperand.FMatrix.AssignTo(
                  FirstOperand.FMatrix.Substr(SecondOperand.FMatrix));
            end;

            '*':
            begin
              if (FirstOperand.FMatrix.Columns <> SecondOperand.FMatrix.Lines) then
              begin
                ShowMessage('First matrix columns does not equal to second' +
                  'matrix lines when multiplying matrixes');
                Result := False;
              end
              else
                ResultOperand.FMatrix.AssignTo(
                  FirstOperand.FMatrix.MultMatr(SecondOperand.FMatrix));
            end;

            '/':
            begin
              ShowMessage('Division of matrixes was found');
              Result := False;
            end;

            '^':
            begin
              ShowMessage('Exponentiation of matrixes was found');
              Result := False;
            end;
          end;
        end;
      end;

      if Result then
        OperatorStack.Pop;
    end
    else
    begin
      ShowMessage('Expression is incorrect');
      Result := False;
    end;
  end;

  if (OperatorStack.Top = '(') and (NewOperator = ')') and Result then
    OperatorStack.Pop
  else
    OperatorStack.Push(NewOperator);
end;

function ExprCalculation(AExpression: string): TOperand;
var
  i: Integer;
  CurrentOperand: string;
  IsCorrectExpression: Boolean;
begin
  OperandStack := TStack<TOperand>.Create;
  OperatorStack := TStack<char>.Create;

  AExpression := '(' + AExpression + ')';
  IsCorrectExpression := True;
  i := 1;
  while (i <= Length(AExpression)) and IsCorrectExpression do
  begin
    IsCorrectExpression := True;

    if AExpression[i] = ' ' then
      inc(i)
    else
      if AExpression[i] in Symbols then
        IsCorrectExpression := OperandProcessing(i, AExpression, OperandStack)
      else if AExpression[i] in Operators then
      begin
        if OperatorStack.IsEmpty then
          OperatorStack.Push(AExpression[i])
        else
          if not OperatorProcessing(AExpression[i],
            OperandStack, OperatorStack) then
              IsCorrectExpression := False;
        Inc(i);
      end
      else
      begin
        ShowMessage('Unkown symbols found');
        IsCorrectExpression := False;
      end;
  end;

  if IsCorrectExpression then
    Result := OperandStack.Top;

  OperandStack.Destroy;
  OperatorStack.Destroy;
end;

end.
