unit untExprCalculate;

interface

uses
  System.SysUtils, clsStack, clsMatrix, untConstants;

var
  OperandStack: TStack<string>;
  OperatorStack: TStack<Char>;

  function ExprCalculation(const Expression: string): string;

implementation

function GetNewPriority(const AOperator: Char): ShortInt;
begin
  case AOperator of
    'A'..'Z', 'a'..'z', '0'..'9':
      Result := 7;
    '+', '-':
      Result := 1;
    '*', '/':
      Result := 3;
    '^':
      Result := 6;
    '(':
      Result := 9;
    ')':
      Result := 0;
    else
      Result := -1;
  end;
end;

function GetStackPriority(const AOperator: Char): ShortInt;
begin
  case AOperator of
    'A'..'Z', 'a'..'z', '0'..'9':
      Result := 8;
    '+', '-':
      Result := 2;
    '*', '/':
      Result := 4;
    '^':
      Result := 5;
    '(':
      Result := 0;
    else
      Result := -1;
  end;
end;

procedure OperandProcessing(var PointerPos: Integer; const Expression: string; var OperandStack: TStack<string>);
var
  Operand: string;
begin
  while Expression[PointerPos] in ['0'..'9', ','] do
  begin
    Operand := Operand + Expression[PointerPos];

    inc(PointerPos);
  end;

  OperandStack.Push(Operand);
end;

procedure OperatorProcessing(var OperandStack: TStack<string>; var OperatorStack: TStack<Char>);
var
  FirstOperand, SecondOperand: TMatrix;

begin



  {//днаюбхрэ опнбепйс мю рхош
  SecondOperand := TMatrix.Create('SecondOper', 1, 1);
  SecondOperand.Elements[0, 0] := StrToFloat(OperandStack.Top);
  OperandStack.Pop;

  FirstOperand := TMatrix.Create('FirstOper', 1, 1);
  FirstOperand.Elements[0, 0] := StrToFloat(OperandStack.Top);
  OperandStack.Pop;

  case (OperatorStack.Top) of
    '+':  OperandStack.Push(FloatToStr(FirstOperand.Add(SecondOperand).Elements[0, 0]));
    '-':  OperandStack.Push(FloatToStr(FirstOperand.Substr(SecondOperand).Elements[0, 0]));
    '*':  OperandStack.Push(FloatToStr(FirstOperand.MultConst(SecondOperand).Elements[0, 0]));
  end;

  OperatorStack.Pop();

  FirstOperand.Destroy();
  SecondOperand.Destroy();    }
end;

function ExprCalculation(const Expression: string): string;
var
  i: Integer;
begin
  OperandStack := TStack<string>.Create;
  OperatorStack := TStack<Char>.Create;

  i := 1;
  while i <= length(Expression) do
  begin
    if Expression[i] in Symbols then
      OperandProcessing(i, Expression, OperandStack);

    if Expression[i] in Operators then
      if OperatorStack.IsEmpty then
        OperatorStack.Push(Expression[i])
      else
      begin
        while (not OperatorStack.IsEmpty) and
          (GetNewPriority(Expression[i]) < GetStackPriority(OperatorStack.Top)) do
          OperatorProcessing(OperandStack, OperatorStack);

        OperatorStack.Push(Expression[i]);
      end;

    inc(i);
  end;

  while not OperatorStack.isEmpty do
  begin
    OperatorProcessing(OperandStack, OperatorStack);
  end;

  Result := OperandStack.Top;

  OperandStack.Destroy;
  OperatorStack.Destroy;
end;


end.
