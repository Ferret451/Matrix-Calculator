unit clsMatrixList;

interface

uses
  clsMatrix, clsSingleLinkedList;

type
  TMatrixList = class(TSingleLinkedList<TMatrix>)

  private

  public
    destructor Destroy(); override;
    procedure Sort();
  end;

implementation

destructor TMatrixList.Destroy();
var
  Node, NextNode: PNode;
begin
  Node := FHead;
  while Assigned(Node) do
  begin
    NextNode := Node.FNext;
    Dispose(Node);
    Node := NextNode;
  end;

  inherited;
end;

procedure TMatrixList.Sort();
var
  CurrNode, LastSwapNode, BarrierNode: PNode;
begin
  BarrierNode := FTail;

  while BarrierNode <> FHead do
  begin
    CurrNode := FHead;
    LastSwapNode := FHead;

    while CurrNode^.FNext <> BarrierNode do
    begin
      if CurrNode^.FValue.Name > CurrNode^.FNext^.FValue.Name then
      begin
        Self.Swap(CurrNode, CurrNode^.FNext);

        LastSwapNode := CurrNode;
      end;

      CurrNode := CurrNode^.FNext;
    end;

    BarrierNode := LastSwapNode;
  end;

end;

end.
