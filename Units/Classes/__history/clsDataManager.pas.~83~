unit clsDataManager;

interface

uses
  Vcl.Grids, Vcl.ExtCtrls, clsMatrixList, clsMatrix, untTypes, untConstants;

type
  TProc = procedure(Sender: TObject);

  TPaintProc = procedure(Sender: TObject);

  TDataManager = class
  private
    FCurrentExpression: TFullOperation;
    FCurrentDeterminant: TFullOperation;
    FCurrentInverse: TFullOperation;
    FCurrentRank: TFullOperation;
    FOperationStatement: TOperationStatement;

    FMatrixList: TMatrixList<Extended>;
  public
    constructor Create();
    destructor Destroy(); override;
    procedure OperationDestroy(const AOpearation: TFullOperation);

    procedure CallBack(Sender: TObject); overload;
    procedure CallBack(const AProc: TProc; const AStringGrid: TStringGrid); overload;

    function GetCurrentOperation(): TFullOperation;

    procedure SetStringProblem(const AProblemString: string;
      const AOperation: TFullOperation);
    procedure SetAnswer(const AAnswer: TAnswer;
      const AOperation: TFullOperation);
    function GetCurrentAnswer(): TAnswer;

    property MatrixList: TMatrixList<Extended> read FMatrixList;
    property CurrentExpression: TFullOperation read FCurrentExpression;
    property CurrentDeterminant: TFullOperation read FCurrentDeterminant;
    property CurrentInverse: TFullOperation read FCurrentInverse;
    property CurrentRank: TFullOperation read FCurrentRank;
    property CurrentAnswer: TAnswer read GetCurrentAnswer;
    property OperationStatement: TOperationStatement read FOperationStatement
      write FOperationStatement;
  end;

var
  DataManager: TDataManager;

implementation

constructor TDataManager.Create();
begin
  FMatrixList := TMatrixList<Extended>.Create();

  FCurrentExpression.FProblemMatrix := TMatrix<string>.Create(
    DefaultMatrixLength, DefaultMatrixHeight);
  FCurrentDeterminant.FProblemMatrix := TMatrix<string>.Create(
    DefaultMatrixLength, DefaultMatrixHeight);
  FCurrentInverse.FProblemMatrix := TMatrix<string>.Create(
    DefaultMatrixLength, DefaultMatrixHeight);
  FCurrentRank.FProblemMatrix := TMatrix<string>.Create(
    DefaultMatrixLength, DefaultMatrixHeight);
  FOperationStatement := ostatExpression;

  inherited;
end;

destructor TDataManager.Destroy();
begin
  FMatrixList.Destroy();

  OperationDestroy(FCurrentExpression);
  OperationDestroy(FCurrentDeterminant);
  OperationDestroy(FCurrentInverse);
  OperationDestroy(FCurrentRank);

  inherited;
end;

procedure TDataManager.OperationDestroy(const AOpearation: TFullOperation);
begin
  AOpearation.FProblemMatrix.Destroy;

  if AOpearation.FAnswer.FIsMatrix then
    AOpearation.FAnswer.FMatrix.Destroy;
end;

procedure TDataManager.CallBack(Sender: TObject);
begin
  TPaintBox(Sender).Invalidate;
end;

procedure TDataManager.CallBack(const AProc: TProc; const AStringGrid: TStringGrid);
begin
  AProc(AStringGrid);
end;

function TDataManager.GetCurrentOperation(): TFullOperation;
begin
  case FOperationStatement of
    ostatExpression: Result := FCurrentExpression;
    ostatDeterminant: Result := FCurrentDeterminant;
    ostatInverse: Result := FCurrentInverse;
    ostatRank: Result := FCurrentRank;
  end;
end;

procedure TDataManager.SetStringProblem(const AProblemString: string;
  const AOperation: TFullOperation);
begin
  FCurrentExpression.FProblemString := AProblemString;
end;

procedure TDataManager.SetAnswer(const AAnswer: TAnswer;
  const AOperation: TFullOperation);
begin
  FCurrentExpression.FAnswer := AAnswer;
end;

function TDataManager.GetCurrentAnswer(): TAnswer;
begin
  Result := GetCurrentOperation.FAnswer;
end;

end.
